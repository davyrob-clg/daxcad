C
C     SCCS id Keywords             @(#)  412.1 date 6/11/92 writecv.f 
C
C     Practical Technology 1990 (c)
C
C     DAXCAD Source file
C
C     Functions and subroutines index:-
C
C     SUBROUTINE RTOSTR(R,STRING,L)
C     SUBROUTINE WRTCV1()
C     SUBROUTINE WRTCV2(OK)
C
C     |-----------------------------------------------------------------|
C
      SUBROUTINE RTOSTR(R,STRING,L)
C     =============================
C1    vartype           R C*(*) I4
C2    iostatus          I   O   O
C
      REAL R
      INTEGER L,NLEN1
      CHARACTER STRING*(*),BUF*32
      EXTERNAL ZSUPP1,NLEN1,CRUNCH
C
C     clear buffer string
      BUF=' '
C     zero length
      L=0
      WRITE(UNIT=BUF,FMT='(G32.16)',ERR=99) R
C     suppress trailing zeroes
      CALL ZSUPP1(BUF)
C     suppress leading spaces
      CALL CRUNCH(BUF)
C     get active length
      L=NLEN1(BUF)
      STRING=BUF(1:L)
 99   CONTINUE
C     return zero length for error
      END
C
C     -------------------------------------------------
C
 
      SUBROUTINE WRTCV1()
C     ========================
C1    no arguments required
C
C2    Saves the current contents of the data base in a disc file
C2    of the name given by the user in response to a request from
C2    this subroutine. In the style of a CV execute file.
C
      include   'include/masti.inc'
      include   'include/nbuff.inc'
      include   'include/filunit.inc'
      include   'include/params.inc'
      include 'include/lfu.inc'
C
      INTEGER*4 NLEN
      CHARACTER*40 FILNM,ANS*1,TDRWNM
      LOGICAL OK,WORKF,YESOK
      EXTERNAL EPRINT,FINDU2,NLEN,SAVALL,YESOK
C
      IF (NMIPOS .EQ. 1) RETURN
C
C     Save temporaryly the correct drawing file name
      TDRWNM=DRGNAM
C
 5    CONTINUE
C
      CALL DPRMXP(81,FILNM)
C
C     if null file name assume abort required
      IF ( NLEN(FILNM).EQ.0 ) THEN
         PARFUN=0
         RETURN
      END IF
C
  7   CONTINUE
C     go find a unit for the file
      CALL FINDU2(PARFUN,FILNM,OK)
C
      IF ( .NOT. OK ) THEN
         CALL DEPRNT(275)
         RETURN
      END IF
C
  6   CONTINUE
C     ensure correct drawing name is used
C
      OPEN(UNIT=PARFUN,FILE=FILNM,ACCESS='SEQUENTIAL',
     1      FORM='FORMATTED',STATUS='NEW',ERR=101)
CIBM
C      LFU(PARFUN)=.TRUE.
CIBM
C
C     go write drawing data in CV EXECUTE file format
      CALL WRTCV2(OK)
C
      CLOSE(UNIT=PARFUN,STATUS='KEEP',ERR=201)
CIBM
C      LFU(PARFUN)=.FALSE.
CIBM
      RETURN
C
 101  CONTINUE
      CALL DPRMXP(282,ANS)
      IF ( YESOK(ANS) ) THEN
         OPEN(UNIT=PARFUN,FILE=FILNM,ACCESS='SEQUENTIAL',
     +   FORM='FORMATTED',STATUS='OLD',ERR=101)
         CLOSE(UNIT=PARFUN,STATUS='DELETE',ERR=201)
         GOTO 6
      ELSE
         GOTO 5
      END IF
C
 201  CALL DCPRNT(82)
C
C     Restore correct drawing file name
      DRGNAM=TDRWNM
C
      END
C
C--------------------------------------------------
C
      SUBROUTINE WRTCV2(OK)
C     =====================
C1    vartyp            L
C1    iostat            O
C
C2    Subroutine WRTCV2 translates the current database
C2    entities into an ASCII file format consistent with
C2    the Computervision CADDS System. The file is a simple
C2    list of CADDS commands which may be executed ditectly
C2    on the target CV system as an EXECUTE file.
C2    This module will successfully transfer all entities of
C2    the following types:
C2        Lines
C2        Arcs
C2        Text
C2    In addition, the layering of the entities will also
C2    be maintained.
C
      include   'include/masti.inc'
      include   'include/nbuff.inc'
      include   'include/filunit.inc'
      include   'include/params.inc'
      include   'include/ndata.inc'
      include   'include/entity.inc'
C
      CHARACTER STRING*128,STRNG2*100
      CHARACTER*32 NUMS(6)
      LOGICAL OK
      REAL SLA,X0,Y0,TMPH,TMPW,DEG,PI,R
      INTEGER*4 CL,NLEN,P,K,L1,L2,LENS(6),I
      INTEGER*2 J,NCHAR,JST
C
      EXTERNAL NLEN,DEG,PI
C
C     A do loop by layer
C
      WRITE(PARFUN,'(A)') '<* EXECUTE File Generated by DAXCAD'
C     set all text to left justified
      WRITE(PARFUN,'(A)') 'SEL TEXT LJT'
C
C     convert data by layer,for efficient reconstruction
C     at CADDS entry.
C     **************************************************
C     ***    Search layer for entities               ***
C     **************************************************
      DO 10 CL=0,255
C       **************************************************
C       ***    Convert entities on current layer       ***
C       **************************************************
C       Check to see if there is anything on the layer
        IF ( TLAYER(CL) .NE. 0 ) THEN
C         entities on layer,select this layer for output
          WRITE(UNIT=PARFUN,FMT='(A,I3)') 'SEL LAY ',CL
C         find all database entities on this layer
C         and write to output
          DO 20 J=1,NMIPOS-1
C           read entity
            CALL DER500(J,OK)
            IF ( .NOT. OK ) THEN
              CALL DEPRNT(729)
              GOTO 19
            END IF
C           If not current layer skip to next
            IF (IMBUFF(4).NE.CL) GOTO 19
C           must not be deleted or master construct entity.
            OK=IMBUFF(1).NE.100 .AND. IMBUFF(1).NE.SYMBM
     +         .AND. IMBUFF(1).NE.COMPM
            IF (OK) THEN
C             ********************************************
C             ***     Start of entity conversion       ***
C             ********************************************
C             clear temp string
              STRNG2=' '
C             convert coords to character strings
              DO 100 I=1,6
                CALL RTOSTR(RDBUFF(I),NUMS(I),LENS(I))
 100          CONTINUE
              IF ( IMBUFF(2) .EQ. LINE ) THEN
C               ********************************************
C               ***     LINE entity                      ***
C               ********************************************
                STRING='INS LIN:'
C               get pointer to first free position in string
                L1=NLEN(STRING)+1
C               add X coord
                STRING(L1:)='X'//NUMS(1)(1:LENS(1))
                L1=L1+LENS(1)+1
C               add Y coord
                STRING(L1:)='Y'//NUMS(2)(1:LENS(2))
                L1=L1+LENS(2)+1
C               add separator and X coord
                STRING(L1:)=',X'//NUMS(4)(1:LENS(4))
                L1=L1+LENS(4)+2
C               add Y coord
                STRING(L1:)='Y'//NUMS(5)(1:LENS(5))
                L1=L1+LENS(5)+1
C               write command line to output file
                WRITE(PARFUN,FMT='(A)') STRING(1:NLEN(STRING))
              ELSE IF ( IMBUFF(2) .EQ. ARC ) THEN
C               ********************************************
C               ***     ARC entity                       ***
C               ********************************************
C               use different command for full circle
C               and circular arc for efficiency
C               use start and end angles to determine
                IF ( ABS(RDBUFF(6)-RDBUFF(5)).GT.PI(2.0)-0.01) THEN
C                 entity is FULL circle
C                 use command form INS CIR R:
                  STRING='INS CIR R:'
C                 get pointer to first free position in string
                  L1=NLEN(STRING)+1
C                 add X coord of centre
                  STRING(L1:)='X'//NUMS(1)(1:LENS(1))
                  L1=L1+LENS(1)+1
C                 add Y coord of centre
                  STRING(L1:)='Y'//NUMS(2)(1:LENS(2))
                  L1=L1+LENS(2)+1
C                 add separator and IX value to circumferential point
                  STRING(L1:)=',IX'//NUMS(4)(1:LENS(4))
                  L1=L1+LENS(4)+2
                ELSE
C                 entity is ARC of circle
C                 use command form INS ARC Rn AGOn AENDn :
                  STRING='INS ARC R'
C                 get pointer to first free position in string
                  L1=NLEN(STRING)+1
C                 add RADIUS of arc
                  STRING(L1:)=NUMS(4)(1:LENS(4))
                  L1=NLEN(STRING)+1
C                 add  START angle in degrees
                  R=DEG(RDBUFF(5))
                  CALL RTOSTR(R,NUMS(5),LENS(5))
                  STRING(L1:)=' AGO'//NUMS(5)(1:LENS(5))
                  L1=NLEN(STRING)+1
C                 add  END angle in degrees
                  R=DEG(RDBUFF(6))
                  CALL RTOSTR(R,NUMS(6),LENS(6))
                  STRING(L1:)=' AEND'//NUMS(6)(1:LENS(6))
                  L1=NLEN(STRING)+2
C                 add separator and X coord of centre point
                  STRING(L1:)=':X'//NUMS(1)(1:LENS(1))
                  L1=NLEN(STRING)+1
C                 add  Y coord of centre point
                  STRING(L1:)='Y'//NUMS(2)(1:LENS(2))
                END IF
C               write command line to output file
                WRITE(PARFUN,FMT='(A/)') STRING(1:NLEN(STRING))
              ELSE IF ( IMBUFF(2) .EQ. TEXT ) THEN
C               ********************************************
C               ***     TEXT entity                      ***
C               ********************************************
C               get no chars in string,slant and justification
                CALL UCODET(RDBUFF(6),SLA,JST,NCHAR)
C               find lower left origin of text
                CALL  XYNORG(RDBUFF(1),RDBUFF(2),JST,RDBUFF(5)
     +               ,SLA,NCHAR,RDBUFF(3),RDBUFF(4),X0,Y0)
C               use command form INS TEXT "
                STRING='INS TEXT "'
C               get pointer to first free position in string
                L1=NLEN(STRING)+1
C               add text string
                STRING(L1:)=CBUFF
                L1=NLEN(STRING)+1
C               close text string
                STRING(L1:L1)='"'
                L1=L1+1
C               reset text origin for bottom left justify
                RDBUFF(1)=X0
                RDBUFF(2)=Y0
C               text width must be in world units
                RDBUFF(3)=RDBUFF(3)*PAPTOW
C               text height must be in world units
                RDBUFF(4)=RDBUFF(4)*PAPTOW
C               use RDBUFF(6) for slant
                RDBUFF(6)=SLA
C               format all parameters
                DO 185 I=1,6
                  CALL RTOSTR(RDBUFF(I),NUMS(I),LENS(I))
 185            CONTINUE
C               now write text parameters
C               add HEIGHT of text
                STRING(L1:)=' HGT'//NUMS(4)(1:LENS(4))
                L1=NLEN(STRING)+1
C               add  WIDTH of text
                STRING(L1:)=' WDT'//NUMS(3)(1:LENS(3))
                L1=NLEN(STRING)+1
C               add ANGLE of text in degrees
                STRING(L1:)=' ANG'//NUMS(5)(1:LENS(5))
                L1=NLEN(STRING)+1
C               add SLANT of text
                STRING(L1:)=' SLT'//NUMS(6)(1:LENS(6))
                L1=NLEN(STRING)+2
C               add command delimiter
                STRING(L1:L1)=':'
                L1=L1+1
C               add X coord of text origin
                STRING(L1:)='X'//NUMS(1)(1:LENS(1))
                L1=L1+LENS(1)+1
C               add Y coord of text origin
                STRING(L1:)='Y'//NUMS(2)(1:LENS(2))
                L1=L1+LENS(2)+1
C               write command line to output file
                WRITE(PARFUN,FMT='(A)') STRING(1:NLEN(STRING))
C             *******************************************
C             ***       End of entity conversion      ***
C             *******************************************
              END IF
            END IF
 19         CONTINUE
 20       CONTINUE
C       **************************************************
C       ***       End of current layer conversion      ***
C       **************************************************
        END IF
 10   CONTINUE
C     **************************************************
C     ***     End of layer search                    ***
C     **************************************************
C
C     tell him that job is complete
      WRITE(PARFUN,'(A)') '<* End of DAXCAD conversion'
C
      END
C
C     -------------------------------------------------
C
